module Queue.Fill exposing (cleanAutoGenerated, ordered, queueLength, shuffled)

{-| These functions will return a new list for the `future` property.
-}

import Date exposing (Date)
import List.Extra as List
import Queue.Types exposing (Item, Model)
import Queue.Utils exposing (makeItem)
import Maybe.Ext as Maybe
import Maybe.Extra as Maybe
import Random exposing (Generator, Seed)
import Tracks.Types exposing (Track)


-- ORDERED


ordered : Date -> List Track -> Model -> List Item
ordered _ rawTracks model =
    let
        tracks =
            purifyTracksList model.ignored rawTracks

        manualEntries =
            List.filter (.manualEntry >> (==) True) model.future

        remaining =
            max (queueLength - (List.length manualEntries)) 0

        focus =
            Maybe.preferFirst (List.last manualEntries) model.activeItem
    in
        case focus of
            Just item ->
                tracks
                    |> List.findIndex ((==) item.track)
                    |> Maybe.map (\idx -> List.drop (idx + 1) tracks)
                    |> Maybe.withDefault tracks
                    |> List.take remaining
                    |> (\a ->
                            let
                                actualRemaining =
                                    remaining - List.length a

                                n =
                                    tracks
                                        |> List.findIndex ((==) item.track)
                                        |> Maybe.withDefault (List.length tracks)
                            in
                                a ++ List.take (min n actualRemaining) tracks
                       )
                    |> List.map (makeItem False)
                    |> List.append manualEntries

            Nothing ->
                tracks
                    |> List.take remaining
                    |> List.map (makeItem False)
                    |> List.append manualEntries



-- SHUFFLED


shuffled : Date -> List Track -> Model -> List Item
shuffled timestamp rawTracks model =
    let
        tracks =
            purifyTracksList model.ignored rawTracks

        amountOfTracks =
            List.length tracks

        generator =
            Random.int 0 (amountOfTracks - 1)

        pastIds =
            List.map (.track >> .id) model.past

        futureIds =
            List.map (.track >> .id) model.future

        activeId =
            Maybe.map (.track >> .id) model.activeItem

        usedIndexes =
            collectIndexes
                tracks
                [ (\t -> List.member t.id pastIds)
                , (\t -> List.member t.id futureIds)
                , (\t -> Just t.id == activeId)
                ]

        usedIndexes_ =
            let
                isUsedUp =
                    List.length usedIndexes >= amountOfTracks

                hasNoFuture =
                    List.isEmpty model.future
            in
                if isUsedUp && hasNoFuture && amountOfTracks > 1 then
                    case amountOfTracks > 1 of
                        True ->
                            collectIndexes tracks [ (\t -> Just t.id == activeId) ]

                        False ->
                            []
                else
                    usedIndexes

        toAmount =
            max (queueLength - (List.length model.future)) 0

        maxAmount =
            max (amountOfTracks - (List.length usedIndexes_)) 0

        howMany =
            min toAmount maxAmount
    in
        if howMany > 0 then
            timestamp
                |> Date.toTime
                |> round
                |> Random.initialSeed
                |> generateIndexes generator howMany usedIndexes_ []
                |> List.map (\idx -> List.getAt idx tracks)
                |> Maybe.values
                |> List.map (makeItem False)
                |> List.append model.future
        else
            model.future


collectIndexes : List Track -> List (Track -> Bool) -> List Int
collectIndexes tracks audits =
    List.indexedFoldl (collector audits) [] tracks


collector : List (Track -> Bool) -> Int -> Track -> List Int -> List Int
collector audits idx track acc =
    case List.foldl (auditor track) False audits of
        True ->
            idx :: acc

        False ->
            acc


auditor : Track -> (Track -> Bool) -> Bool -> Bool
auditor track audit acc =
    if acc == True then
        acc
    else
        audit track


{-| Generated random indexes.

    `squirrel` = accumulator, ie. collected indexes

-}
generateIndexes : Generator Int -> Int -> List Int -> List Int -> Seed -> List Int
generateIndexes generator howMany usedIndexes squirrel seed =
    let
        ( index, newSeed ) =
            Random.step generator seed

        newSquirrel =
            if List.member index usedIndexes then
                squirrel
            else if List.member index squirrel then
                squirrel
            else
                index :: squirrel
    in
        if List.length newSquirrel < howMany then
            generateIndexes generator howMany usedIndexes newSquirrel newSeed
        else
            newSquirrel



-- Cleaning crew


cleanAutoGenerated : Bool -> String -> List Item -> List Item
cleanAutoGenerated shuffle trackId future =
    case shuffle of
        True ->
            List.filterNot
                (\i -> i.manualEntry == False && i.track.id == trackId)
                future

        False ->
            future


purifyTracksList : List Item -> List Track -> List Track
purifyTracksList ignored tracks =
    let
        ignoredTrackIds =
            List.map (.track >> .id) ignored
    in
        tracks
            |> List.foldr purifyTracksListReducer ( [], ignoredTrackIds )
            |> Tuple.first


purifyTracksListReducer : Track -> ( List Track, List String ) -> ( List Track, List String )
purifyTracksListReducer track ( collection, ignored ) =
    case List.findIndex ((==) track.id) ignored of
        Just idx ->
            ( collection, List.removeAt idx ignored )

        Nothing ->
            ( track :: collection, ignored )



-- Constants


queueLength : Int
queueLength =
    30
